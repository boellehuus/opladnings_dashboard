<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Tesla Ladeplan med Solm√∏ller</title>
    <!-- 
    TESLA DASHBOARD MED SOLM√òLLER INTEGRATION - KOMPLET VERSION
    ==========================================================
    üîã Original Tesla dashboard funktionalitet
    üí± EUR/DKK kurs-fetching med 24h cache
    üìä Henrik Solm√∏ller 7-dages prognose integration
    üí∞ Smart price enhancement (spot + tariffer + moms)
    üéØ 7-dages UI med smart data prioritering
    üïí Copenhagen timezone h√•ndtering
    üîß Debug utilities og system monitoring
    -->
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
    }
    
    body {
        background: #f5f5f7;
        font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', Arial, sans-serif;
        color: #1d1d1f;
        min-height: 100vh;
        padding: 12px;
        overflow-x: hidden;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }
    
    .container {
        max-width: 100%;
        width: 450px;
        margin: 0 auto;
        background: white;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        border: 1px solid #e5e5e7;
    }
    
    @media (max-width: 480px) {
        body {
            padding: 8px;
        }
        
        .container {
            width: 100%;
            padding: 14px;
            border-radius: 12px;
        }
    }
    
    .time-selector {
        display: flex;
        background: #f2f2f7;
        border-radius: 12px;
        padding: 3px;
        margin-bottom: 16px;
        overflow-x: auto;
        scrollbar-width: none;
        -ms-overflow-style: none;
    }
    
    .time-selector::-webkit-scrollbar {
        display: none;
    }
    
    .time-option {
        flex: 1;
        min-width: 55px;
        text-align: center;
        padding: 8px 12px;
        border-radius: 9px;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        user-select: none;
        -webkit-user-select: none;
        touch-action: manipulation;
        color: #86868b;
        white-space: nowrap;
    }
    
    .time-option:active {
        transform: scale(0.96);
    }
    
    .time-option.active {
        background: white;
        color: #1d1d1f;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    .chart-container {
        height: 140px;
        margin-bottom: 16px;
        position: relative;
        background: #fafafa;
        border-radius: 12px;
        padding: 16px 12px 8px 12px;
        border: 1px solid #e5e5e7;
    }
    
    .empty-state {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #86868b;
    }
    
    .empty-state .main-message {
        font-size: 16px;
        font-weight: 600;
        color: #1d1d1f;
        margin-bottom: 8px;
    }
    
    .empty-state .sub-message {
        font-size: 12px;
        color: #86868b;
        text-align: center;
        line-height: 1.4;
    }
    
    .chart {
        display: flex;
        align-items: end;
        height: 100px;
        padding: 0;
        gap: 3px;
        position: relative;
    }
    
    .bar {
        flex: 1;
        border-radius: 3px 3px 0 0;
        transition: all 0.2s ease;
        position: relative;
        cursor: pointer;
        min-height: 4px;
    }
    
    .bar:hover {
        transform: translateY(-1px);
        filter: brightness(0.9);
    }
    
    .bar:active {
        transform: translateY(0px);
    }
    
    .bar.touch-active {
        transform: translateY(-1px);
        filter: brightness(0.9);
    }
    
    .bar.charging {
        background: repeating-linear-gradient(
            45deg,
            #ffffff,
            #ffffff 3px,
            rgba(48, 209, 88, 0.7) 3px,
            rgba(48, 209, 88, 0.7) 6px
        );
        box-shadow: 0 0 8px rgba(48, 209, 88, 0.4);
        border: 1px solid rgba(48, 209, 88, 0.8);
        animation: charging-pulse 2s infinite;
    }
    
    .bar.charging.past {
        background: repeating-linear-gradient(
            45deg,
            #f0f0f0,
            #f0f0f0 3px,
            rgba(36, 138, 61, 0.4) 3px,
            rgba(36, 138, 61, 0.4) 6px
        );
        opacity: 0.6;
        animation: none;
    }
    
    .bar.current-time {
        background: #9370DB;
    }
    
    .bar.green { background: #30d158; }
    .bar.green.past { background: #248a3d; opacity: 0.6; }
    
    .bar.orange { background: #ff9500; }
    .bar.orange.past { background: #cc7700; opacity: 0.6; }
    
    .bar.red { background: #ff3b30; }
    .bar.red.past { background: #cc2e26; opacity: 0.6; }
    
    .bar.purple { background: #af52de; }
    .bar.purple.past { background: #8c42b1; opacity: 0.6; }
    
    .time-labels {
        display: flex;
        justify-content: space-between;
        margin-top: 8px;
        font-size: 11px;
        color: #86868b;
        padding: 0 2px;
        font-weight: 500;
    }
    
    .tooltip-portal {
        position: fixed;
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 11px;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 10000;
        top: 0;
        left: 0;
        backdrop-filter: blur(10px);
    }
    
    .tooltip-portal.visible {
        opacity: 1;
    }
    
    .data-source {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        font-size: 10px;
        color: #86868b;
        margin-bottom: 12px;
        padding: 4px 8px;
        background: #f8f8f8;
        border-radius: 6px;
        border: 1px solid #e8e8e8;
    }
    
    .reliability-indicator {
        font-size: 12px;
        font-weight: bold;
    }
    
    .summary-card {
        background: #f2f2f7;
        border-radius: 12px;
        padding: 6px 16px;
        border: 1px solid #e5e5e7;
        text-align: center;
        min-height: auto;
        line-height: 1.2;
    }
    
    .summary-title {
        font-size: 11px;
        color: #86868b;
        margin-bottom: 4px;
        font-weight: 500;
        line-height: 1.1;
    }
    
    .summary-price {
        font-size: 13px;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        color: #1d1d1f;
        line-height: 1.1;
    }
    
    .summary-divider {
        color: #86868b;
        font-weight: 400;
    }
    
    .charging-start {
        font-size: 11px;
        color: #86868b;
        margin-top: 6px;
        font-weight: 500;
        line-height: 1.1;
    }
    
    @keyframes charging-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.8; }
    }
    
    @media (prefers-reduced-motion: reduce) {
        * {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }
    }
</style>
</head>
<body>
    <div class="container">
        <!-- 6-DAY SELECTOR - Genereres dynamisk i JavaScript (UDEN i g√•r) -->
        <div class="time-selector">
            <div class="time-option active" onclick="switchDay('today')">I dag</div>
        </div>

        <!-- CHART CONTAINER -->
        <div class="chart-container">
            <div class="chart" id="priceChart"></div>
            <div class="time-labels">
                <span>00</span>
                <span>06</span>
                <span>12</span>
                <span>18</span>
                <span>24</span>
            </div>
        </div>
        
        <!-- DATA SOURCE INDICATOR -->
        <div class="data-source">
            <span id="dataSource">Tesla data</span>
            <span id="reliability" class="reliability-indicator">‚óè</span>
        </div>
        
        <!-- LADEINFO SUMMARY -->
        <div class="summary-card">
            <div class="summary-title">Ladeinfo</div>
            <div class="summary-price">
                <span id="kWhNeeded">0 kWh</span>
                <span class="summary-divider">|</span>
                <span id="totalCost">0 kr</span>
            </div>
            <div class="charging-start" id="chargingStart">
                Ladning ikke planlagt
            </div>
        </div>
    </div>

    <!-- TOOLTIP PORTAL -->
    <div id="tooltipPortal" class="tooltip-portal"></div>

<script>
    // ==============================================
    // TESLA DASHBOARD - KOMPLET JAVASCRIPT IMPLEMENTATION
    // ==============================================

    // GLOBAL STATE - Enhanced for 7-day Henrik integration
    let currentDay = 'today';
    let currentTeslaData = null;
    let refreshTimer = null;
    let isPageVisible = true;
    let hasLiveTeslaData = false;

    // Enhanced configuration with all integration endpoints
    const CONFIG = {
        refreshInterval: 60000,
        retryAttempts: 3,
        retryDelay: 2000,
        dataURL: 'https://gist.githubusercontent.com/boellehuus/ac3fe4331b033d941cdc836936d4c3c9/raw/elbil-data.json',
        
        // STEP 1: EUR/DKK Exchange Rate Configuration
        exchangeRateURL: 'https://www.nationalbanken.dk/api/currencyrates',
        exchangeRateFallbackURL: 'https://api.exchangerate-api.com/v4/latest/EUR',
        cachedEURRate: 7.44, // Fallback v√¶rdi
        lastRateUpdate: null,
        
        // STEP 2: Henrik Solm√∏ller Configuration
        solmollerURL: 'https://raw.githubusercontent.com/solmoller/Spotprisprognose/main/prognose.json',
        solmollerArea: 'DK1', // Vestdanmark - som √∏nsket
        
        // STEP 6: BilligkWh API Configuration
        billigkwhURL: 'https://billigkwh.dk/api/Priser/HentPriser?sted=DK1&netselskab=vores_elnet&produkt=greenbow_elaftale'
    };

    // 3-DAY TESLA PRICE DATA STRUCTURE (original) - UDEN yesterday
    const priceDataSet = {
        today: [],
        tomorrow: []
    };

    // 7-DAY HENRIK DATA STRUCTURE - UDEN yesterday
    const henrikDataSet = {
        today: [],
        tomorrow: [],
        day2: [],
        day3: [],
        day4: [],
        day5: [],
        day6: []
    };

    // STEP 6: 2-DAY BILLIGKWH DATA STRUCTURE - UDEN yesterday  
    const billigkwhDataSet = {
        today: [],
        tomorrow: []
    };

    // Enhanced charging schedule for 6 days - UDEN yesterday
    const chargingSchedule = {
        today: [],
        tomorrow: [],
        day2: [],
        day3: [],
        day4: [],
        day5: [],
        day6: []
    };

    // Current price data (points to one of the above based on currentDay)
    let priceData = [];

    // Price enhancement components
    const defaultTariffComponents = {
        elafgift: 0.697,        // Fast dansk elafgift kr/kWh
        nettarif: 0.65,         // Gennemsnit transport kr/kWh  
        systemtarif: 0.12,      // Energinet tarif kr/kWh
        spottillaeg: 0.05,      // Elselskab margin kr/kWh
        momsRate: 1.25          // 25% moms
    };

    let calibratedTariffComponents = null;

    ‚úÖ BilligkWh integration successful - using for i g√•r/i dag');
            } else {
                console.log('‚ö†Ô∏è BilligkWh failed - falling back to Tesla + Henrik');
            }
            
            // STEP 3: Henrik data fetch and calibration
            try {
                console.log('üîÑ Attempting Henrik data fetch and calibration...');
                const henrikData = await fetchSolmollerData();
                
                if (henrikData) {
                    // Try calibration if we have overlapping data (pass billigkwh data)
                    const calibration = calculateActualMissingComponents(teslaData, henrikData, eurRate, billigkwhData);
                    
                    if (calibration) {
                        calibratedTariffComponents = calibration;
                        console.log('‚úÖ Tariff calibration successful');
                    } else {
                        console.log('‚ö†Ô∏è No overlapping data for calibration, using defaults');
                    }
                    
                    // Enhance Henrik data with tariffs
                    await enhanceAllHenrikData();
                } else {
                    console.log('‚ö†Ô∏è Henrik data not available');
                }
                
            } catch (henrikError) {
                console.warn('‚ö†Ô∏è Henrik integration failed:', henrikError);
                // Continue with BilligkWh + Tesla functionality
            }
            
            if (!refreshTimer) {
                refreshTimer = setInterval(fetchTeslaData, CONFIG.refreshInterval);
                console.log('üîÑ STATUS: Auto-refresh timer started');
            }
            
        } catch (error) {
            console.error('‚ùå STATUS: Data fetch error:', error);
            handleFetchError(error);
        }
    }

    // Update UI with Tesla data
    function updateUIWithTeslaData(teslaData) {
        console.log('üîÑ STATUS: Updating UI with Tesla data...');
        
        currentTeslaData = teslaData;
        hasLiveTeslaData = true;
        
        // Update fixed ladeinfo
        updateFixedLadeinfo(teslaData);
        
        // Update 3-day price data
        updatePriceDataSet(teslaData);
        
        // Update charging hours
        updateChargingHours(teslaData);
        
        // Point to current day's data - UDEN yesterday
        if (currentDay === 'today') {
            priceData = priceDataSet.today;
        } else if (currentDay === 'tomorrow') {
            priceData = priceDataSet.tomorrow;
        }
        
        // Regenerate chart
        generateChart();
        
        console.log('‚úÖ STATUS: UI update completed');
    }

    // Update Tesla price data structure - UDEN yesterday
    function updatePriceDataSet(teslaData) {
        console.log('üîÑ STATUS: Updating Tesla price data...');
        
        if (teslaData.Elbil_price_data_today && Array.isArray(teslaData.Elbil_price_data_today)) {
            priceDataSet.today = teslaData.Elbil_price_data_today;
            console.log('‚úÖ Tesla i dag priser loaded:', priceDataSet.today.length, 'timer');
        } else {
            priceDataSet.today = [];
        }
        
        if (teslaData.Elbil_price_data_tomorrow && Array.isArray(teslaData.Elbil_price_data_tomorrow)) {
            priceDataSet.tomorrow = teslaData.Elbil_price_data_tomorrow;
            console.log('‚úÖ Tesla i morgen priser loaded:', priceDataSet.tomorrow.length, 'timer');
        } else {
            priceDataSet.tomorrow = [];
        }
        
        console.log('‚úÖ STATUS: Tesla price data update completed');
    }

    // Update fixed charging info from Tesla
    function updateFixedLadeinfo(teslaData) {
        if (teslaData.Elbil_total_cost !== null && teslaData.Elbil_total_cost !== undefined && teslaData.Elbil_total_cost > 0) {
            document.getElementById('totalCost').textContent = 
                parseFloat(teslaData.Elbil_total_cost).toFixed(2).replace('.', ',') + ' kr';
        } else {
            document.getElementById('totalCost').textContent = '0 kr';
        }
        
        if (teslaData.Elbil_kWh_needed !== null && teslaData.Elbil_kWh_needed !== undefined && teslaData.Elbil_kWh_needed > 0) {
            document.getElementById('kWhNeeded').textContent = 
                parseFloat(teslaData.Elbil_kWh_needed).toFixed(2).replace('.', ',') + ' kWh';
        } else {
            document.getElementById('kWhNeeded').textContent = '0 kWh';
        }
        
        if (teslaData.Elbil_compact_schedule && teslaData.Elbil_compact_schedule !== '') {
            document.getElementById('chargingStart').textContent = teslaData.Elbil_compact_schedule;
        } else {
            document.getElementById('chargingStart').textContent = 'Ladning ikke planlagt';
        }
    }

    // Update charging hours schedule - enhanced for 6 days UDEN yesterday
    function updateChargingHours(teslaData) {
        // Reset all days - reduced to 6 days
        chargingSchedule.today = [];
        chargingSchedule.tomorrow = [];
        chargingSchedule.day2 = [];
        chargingSchedule.day3 = [];
        chargingSchedule.day4 = [];
        chargingSchedule.day5 = [];
        chargingSchedule.day6 = [];
        
        if (teslaData.Elbil_optimal_start_time && teslaData.Elbil_charging_hours && teslaData.Elbil_compact_schedule) {
            try {
                const startTime = teslaData.Elbil_optimal_start_time.toString();
                const chargingHours = parseInt(teslaData.Elbil_charging_hours);
                const schedule = teslaData.Elbil_compact_schedule.toString();
                
                if (startTime.includes(':')) {
                    const startHour = parseInt(startTime.split(':')[0]);
                    
                    let targetDay = 'today';
                    const scheduleLC = schedule.toLowerCase();
                    if (scheduleLC.includes('i morgen')) {
                        targetDay = 'tomorrow';
                    } else if (scheduleLC.includes('i dag')) {
                        targetDay = 'today';
                    }
                    // Fjernet "i g√•r" h√•ndtering
                    
                    for (let i = 0; i < chargingHours; i++) {
                        const hour = (startHour + i) % 24;
                        chargingSchedule[targetDay].push(hour);
                    }
                    
                    console.log(`‚ö° Tesla charging scheduled for ${targetDay}:`, chargingSchedule[targetDay]);
                }
            } catch (error) {
                console.log('‚ö†Ô∏è Could not parse Tesla charging hours:', error);
            }
        }
    }

    // Handle fetch errors - UDEN yesterday
    function handleFetchError(error) {
        hasLiveTeslaData = false;
        priceDataSet.today = [];
        priceDataSet.tomorrow = [];
        
        // Clear Henrik data ved fejl  
        Object.keys(henrikDataSet).forEach(day => henrikDataSet[day] = []);
        
        // Clear BilligkWh data ved fejl
        Object.keys(billigkwhDataSet).forEach(day => billigkwhDataSet[day] = []);
        
        priceData = [];
        
        document.getElementById('totalCost').textContent = '0 kr';
        document.getElementById('kWhNeeded').textContent = '0 kWh';
        document.getElementById('chargingStart').textContent = 'Ladning ikke planlagt';
        
        // Reset charging schedule for all days - UDEN yesterday
        chargingSchedule.today = [];
        chargingSchedule.tomorrow = [];
        chargingSchedule.day2 = [];
        chargingSchedule.day3 = [];
        chargingSchedule.day4 = [];
        chargingSchedule.day5 = [];
        chargingSchedule.day6 = [];
        
        generateChart();
    }

    // Battery optimization for mobile devices
    function startBatteryOptimization() {
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                isPageVisible = false;
                if (refreshTimer) {
                    clearInterval(refreshTimer);
                    refreshTimer = null;
                    console.log('‚è∏Ô∏è Auto-refresh paused');
                }
            } else {
                isPageVisible = true;
                if (!refreshTimer) {
                    refreshTimer = setInterval(fetchTeslaData, CONFIG.refreshInterval);
                    console.log('‚ñ∂Ô∏è Auto-refresh resumed');
                    fetchTeslaData();
                }
            }
        });
    }

    console.log('Tesla data integration and main fetch functions created');

    // ==============================================
    // STEP 5: SYSTEM HEALTH + DEBUG UTILITIES
    // ==============================================

    // System health check and diagnostics
    function performSystemHealthCheck() {
        const now = new Date();
        const copenhagenTime = new Date(now.toLocaleString("en-US", {timeZone: "Europe/Copenhagen"}));
        
        const health = {
            timestamp: now.toISOString(),
            copenhagenTime: copenhagenTime.toISOString(),
            timezoneOffset: now.getTimezoneOffset(),
            eurRate: {
                value: CONFIG.cachedEURRate,
                lastUpdate: CONFIG.lastRateUpdate,
                age: CONFIG.lastRateUpdate ? (Date.now() - CONFIG.lastRateUpdate.getTime()) / (60 * 60 * 1000) : 'unknown'
            },
            teslaData: {
                available: hasLiveTeslaData,
                days: Object.keys(priceDataSet).filter(day => 
                    priceDataSet[day] && priceDataSet[day].length === 24
                )
            },
            henrikData: {
                available: Object.keys(henrikDataSet).some(day => hasHenrikDataForDay(day)),
                days: Object.keys(henrikDataSet).filter(day => hasHenrikDataForDay(day))
            },
            billigkwhData: {
                available: Object.keys(billigkwhDataSet).some(day => hasBilligkWhDataForDay(day)),
                days: Object.keys(billigkwhDataSet).filter(day => hasBilligkWhDataForDay(day))
            },
            calibration: {
                active: calibratedTariffComponents !== null,
                reliability: calibratedTariffComponents?.reliability || 'none'
            },
            currentDay: currentDay,
            dataSource: getDataForDay(currentDay).source
        };
        
        console.log('üè• SYSTEM HEALTH CHECK:');
        console.log('üïí Copenhagen Time:', health.copenhagenTime);
        console.log('üåç Browser Time:', health.timestamp);
        console.log('‚è∞ Timezone Offset:', health.timezoneOffset, 'minutes');
        console.log('üí± EUR Rate:', health.eurRate);
        console.log('üöó Tesla Data:', health.teslaData);
        console.log('üìä Henrik Data:', health.henrikData);
        console.log('üí∞ BilligkWh Data:', health.billigkwhData);
        console.log('üîß Calibration:', health.calibration);
        console.log('üìÖ Current:', health.currentDay, '->', health.dataSource);
        
        return health;
    }

    // Test all integrations
    function runIntegrationTests() {
        console.log('üß™ Running integration tests...');
        
        const tests = {
            eurRateLoading: loadCachedRate(),
            dayButtonGeneration: generateDayButtons().length === 6,
            dataSourcePrioritization: getDataForDay('today').source !== undefined,
            chartGeneration: document.getElementById('priceChart') !== null,
            tooltipSystem: document.getElementById('tooltipPortal') !== null,
            configValid: CONFIG.solmollerURL.includes('github'),
            dataStructures: Object.keys(henrikDataSet).length === 7
        };
        
        const passed = Object.values(tests).filter(result => result === true).length;
        const total = Object.keys(tests).length;
        
        console.log(`üß™ Integration tests: ${passed}/${total} passed`);
        console.log('üìã Test details:', tests);
        
        if (passed === total) {
            console.log('‚úÖ All systems operational!');
        } else {
            console.warn('‚ö†Ô∏è Some integration issues detected');
        }
        
        return tests;
    }

    // Debug command interface
    function createDebugInterface() {
        // Enhanced debugging with BilligkWh comparison
        window.debugDashboard = {
            health: performSystemHealthCheck,
            test: runIntegrationTests,
            switchDay: switchDayEnhanced,
            eurRate: () => CONFIG.cachedEURRate,
            teslaData: () => priceDataSet,
            henrikData: () => henrikDataSet,
            billigkwhData: () => billigkwhDataSet,
            calibration: () => calibratedTariffComponents,
            refresh: fetchTeslaData,
            config: () => CONFIG,
            forceHenrikFetch: fetchSolmollerData,
            forceBilligkwhFetch: fetchBilligkWhData,
            forceEnhancement: enhanceAllHenrikData,
            comparePrices: () => {
                console.log('üîç PRICE COMPARISON FOR TODAY:');
                if (hasBilligkWhDataForDay('today')) {
                    const billigkwh = billigkwhDataSet.today;
                    const avgBilligkwh = billigkwh.reduce((sum, p) => sum + p, 0) / 24;
                    console.log('üí∞ BilligkWh avg:', avgBilligkwh.toFixed(3), 'kr/kWh');
                }
                if (hasHenrikDataForDay('today')) {
                    const henrik = henrikDataSet.today;
                    const avgHenrik = henrik.reduce((sum, p) => sum + p, 0) / 24;
                    console.log('üìä Henrik enhanced avg:', avgHenrik.toFixed(3), 'kr/kWh');
                }
                if (priceDataSet.today.length === 24) {
                    const tesla = priceDataSet.today;
                    const avgTesla = tesla.reduce((sum, p) => sum + p, 0) / 24;
                    console.log('üöó Tesla avg:', avgTesla.toFixed(3), 'kr/kWh');
                }
                return {billigkwh: billigkwhDataSet.today, henrik: henrikDataSet.today, tesla: priceDataSet.today};
            }
        };
        
        console.log('üîß Debug interface created: window.debugDashboard');
        console.log('üí° Try: window.debugDashboard.health()');
    }

    console.log('STEP 5: System health and debug utilities created');

    // ==============================================
    // EVENT HANDLERS + INITIALIZATION
    // ==============================================

    // Enhanced initialization function
    function init() {
        console.log('üîÑ STATUS: Initializing enhanced dashboard...');
        
        // Initialize with no data state
        document.getElementById('totalCost').textContent = '0 kr';
        document.getElementById('kWhNeeded').textContent = '0 kWh';
        document.getElementById('chargingStart').textContent = 'Ladning ikke planlagt';
        
        // STEP 1: Load cached exchange rate ved startup
        loadCachedRate();
        
        // STEP 1: Fetch fresh rate non-blocking
        fetchExchangeRate().catch(err => console.log('EUR rate fetch failed:', err));
        
        // STEP 4: Generate 6-day selector
        updateDaySelector();
        
        // STEP 4: Initialize enhanced data structures
        Object.keys(henrikDataSet).forEach(day => henrikDataSet[day] = []);
        Object.keys(billigkwhDataSet).forEach(day => billigkwhDataSet[day] = []);
        
        // Clear all price data initially - UDEN yesterday
        priceDataSet.today = [];
        priceDataSet.tomorrow = [];
        priceData = priceDataSet.today; // Default to today
        
        // Show empty state initially
        generateChart();
        
        // Start battery optimization
        startBatteryOptimization();
        
        // Create debug interface
        createDebugInterface();
        
        // Try to fetch live Tesla data
        fetchTeslaData();
        
        // STEP 5: Run integration tests
        setTimeout(() => {
            const testResults = runIntegrationTests();
            console.log('üß™ Initial test results:', testResults);
        }, 1000);
        
        // STEP 5: Perform health check
        setTimeout(() => {
            performSystemHealthCheck();
        }, 2000);
        
        console.log('‚úÖ STATUS: Enhanced dashboard initialization completed');
        console.log('üéØ FINAL STATUS: All 5 steps implemented successfully!');
        console.log('üìä Features: 6-day UI, EUR rate caching, Henrik integration, smart prioritization, enhanced UX');
    }

    // Hide tooltip when clicking outside bars
    document.addEventListener('click', function(e) {
        if (!e.target.classList.contains('bar')) {
            hideTooltip();
        }
    });

    // Handle page visibility for battery optimization
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            console.log('üì± Page hidden - pausing refresh');
        } else {
            console.log('üì± Page visible - resuming refresh');
        }
    });

    // Error handling for unhandled promises
    window.addEventListener('unhandledrejection', function(event) {
        console.error('üö® Unhandled promise rejection:', event.reason);
        // Don't prevent default to keep error visible in console
    });

    // Error handling for general errors
    window.addEventListener('error', function(event) {
        console.error('üö® JavaScript error:', event.error);
    });

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', init);

    // Expose global functions for backward compatibility and debugging
    window.switchDay = switchDay;
    window.generateChart = generateChart;
    window.fetchTeslaData = fetchTeslaData;

        console.log('STATUS: Event handlers and initialization setup completed');
        console.log('READY: Tesla dashboard med Henrik Solmoller integration');
        console.log('DEBUG: Brug window.debugDashboard.health() for system status');
        console.log('MOBILE: Optimeret til iOS webapp og responsive design');
        console.log('TIMEZONE: Konfigureret til Copenhagen/Europe timezone');
        console.log('CURRENCY: EUR/DKK kurs cached i 24 timer');
        console.log('DATA: Tesla prioriteret, Henrik backup + 7-dages prognose');
        console.log('CHARGING: Smart tariff calibration og price enhancement');

    // Final status message
    setTimeout(() => {
        console.log('');
        console.log('================================================');
        console.log('TESLA DASHBOARD ENHANCED - FULLY OPERATIONAL');  
        console.log('================================================');
        console.log('6-DAY FORECAST: Henrik Solmoller integration');
        console.log('EXCHANGE RATE: Daily EUR/DKK caching');
        console.log('PRICE ENHANCE: Spot + tariffer + moms');
        console.log('SMART PRIORITY: BilligkWh -> Tesla -> Henrik');
        console.log('TIMEZONE SAFE: Copenhagen time handling');
        console.log('DEBUG READY: window.debugDashboard.*');
        console.log('MOBILE OPTIM: Battery + responsive design');
        console.log('================================================');
    }, 3000);

</script>
</body>
</html>üîÑ STATUS: Global state og data strukturer oprettet');

    // ==============================================
    // STEP 1: EUR/DKK EXCHANGE RATE FUNCTIONS
    // ==============================================

    // Load cached exchange rate from localStorage
    function loadCachedRate() {
        try {
            const cached = localStorage.getItem('eurRate');
            const timestamp = localStorage.getItem('rateTimestamp');
            
            if (cached && timestamp) {
                const age = Date.now() - parseInt(timestamp);
                if (age < 24 * 60 * 60 * 1000) { // Under 24 timer gammel
                    CONFIG.cachedEURRate = parseFloat(cached);
                    CONFIG.lastRateUpdate = new Date(parseInt(timestamp));
                    console.log('üì± Loaded cached EUR rate:', CONFIG.cachedEURRate);
                    return true;
                }
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Could not load cached rate:', error);
        }
        return false;
    }

    // Fetch fresh EUR/DKK exchange rate (max once per 24h)
    async function fetchExchangeRate() {
        try {
            const now = new Date();
            const lastUpdate = CONFIG.lastRateUpdate;
            
            // Kun hent hvis mere end 24 timer siden sidste opdatering
            if (lastUpdate && (now - lastUpdate) < 24 * 60 * 60 * 1000) {
                return CONFIG.cachedEURRate;
            }
            
            console.log('üìà Fetching new EUR/DKK rate...');
            
            let eurRate = null;
            
            // Pr√∏v Danmarks Nationalbank f√∏rst
            try {
                const response = await fetch(CONFIG.exchangeRateURL);
                if (response.ok) {
                    const rates = await response.json();
                    const eurRateObj = rates.find(rate => rate.currency === 'EUR');
                    if (eurRateObj && eurRateObj.rate) {
                        eurRate = eurRateObj.rate;
                        console.log('‚úÖ EUR/DKK from Nationalbank:', eurRate);
                    }
                }
            } catch (error) {
                console.log('‚ö†Ô∏è Nationalbank failed, trying fallback...');
            }
            
            // Fallback til exchangerate-api
            if (!eurRate) {
                try {
                    const response = await fetch(CONFIG.exchangeRateFallbackURL);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.rates && data.rates.DKK) {
                            eurRate = data.rates.DKK;
                            console.log('‚úÖ EUR/DKK from fallback:', eurRate);
                        }
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Fallback API failed:', error);
                }
            }
            
            // Opdater cache hvis succesfuld
            if (eurRate && eurRate > 6 && eurRate < 9) { // Sanity check
                CONFIG.cachedEURRate = eurRate;
                CONFIG.lastRateUpdate = now;
                
                // Gem i localStorage
                localStorage.setItem('eurRate', eurRate.toString());
                localStorage.setItem('rateTimestamp', now.getTime().toString());
                
                console.log('‚úÖ EUR/DKK rate updated and cached:', eurRate);
            } else {
                console.warn('‚ö†Ô∏è Invalid rate received, using cached:', CONFIG.cachedEURRate);
            }
            
            return CONFIG.cachedEURRate;
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Could not fetch exchange rate, using cached:', CONFIG.cachedEURRate);
            return CONFIG.cachedEURRate;
        }
    }

    console.log('STEP 1: EUR/DKK exchange rate functions created');

    // ==============================================
    // STEP 2: HENRIK SOLM√òLLER DATA FUNCTIONS
    // ==============================================

    // Fetch Henrik Solm√∏ller 7-day forecast
    async function fetchSolmollerData() {
        try {
            console.log('üîÑ Fetching Henrik Solm√∏ller 7-day forecast...');
            
            const response = await fetch(CONFIG.solmollerURL + '?t=' + Date.now());
            
            if (!response.ok) {
                throw new Error(`Henrik API HTTP ${response.status}`);
            }
            
            const henrikData = await response.json();
            console.log('‚úÖ Henrik data received');
            console.log('üìÖ Forecast created:', henrikData["Forecast created"]);
            console.log('üó∫Ô∏è Available areas:', Object.keys(henrikData).filter(key => key.startsWith('DK')));
            
            // Parse og organiser Henrik data i 7-dages struktur
            updateHenrikDataSet(henrikData);
            
            return henrikData;
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Henrik data fetch failed:', error);
            // Clear Henrik data ved fejl
            Object.keys(henrikDataSet).forEach(day => henrikDataSet[day] = []);
            return null;
        }
    }

    // Organiser Henrik data i daglige arrays med Copenhagen timezone
    function updateHenrikDataSet(henrikData) {
        try {
            console.log('üîÑ Organizing Henrik data into 7-day structure...');
            
            // Clear existing data
            Object.keys(henrikDataSet).forEach(day => henrikDataSet[day] = []);
            
            if (!henrikData || !henrikData.DK1) {
                console.warn('‚ö†Ô∏è Invalid Henrik data format - missing DK1 data');
                return;
            }
            
            // Get current Copenhagen time for day calculations
            const now = new Date();
            const copenhagenNow = new Date(now.toLocaleString("en-US", {timeZone: "Europe/Copenhagen"}));
            const copenhagenToday = new Date(copenhagenNow.getFullYear(), copenhagenNow.getMonth(), copenhagenNow.getDate());
            
            // Henrik's data structure: {"Forecast created": "2025-06-05T15:12:10", "DK1": [...], "DK2": [...]}
            const areaData = henrikData[CONFIG.solmollerArea] || henrikData.DK1;
            
            console.log(`üìç Processing ${CONFIG.solmollerArea} data:`, areaData.length, 'entries');
            console.log('üìÖ Forecast created:', henrikData["Forecast created"]);
            console.log('üïí Copenhagen current time:', copenhagenNow.toISOString());
            
            // Organiser data efter dage - Henrik format: {"Time": "2025-06-05T14:00:00", "Price": 58.0}
            areaData.forEach(entry => {
                try {
                    // Parse Henrik's UTC time
                    const utcDate = new Date(entry.Time + 'Z'); // Ensure UTC parsing
                    
                    // Convert to Copenhagen time
                    const copenhagenDate = new Date(utcDate.toLocaleString("en-US", {timeZone: "Europe/Copenhagen"}));
                    const copenhagenHour = copenhagenDate.getHours();
                    const price = parseFloat(entry.Price);
                    
                    // Calculate day offset from Copenhagen today
                    const copenhagenDay = new Date(copenhagenDate.getFullYear(), copenhagenDate.getMonth(), copenhagenDate.getDate());
                    const daysDiff = Math.floor((copenhagenDay - copenhagenToday) / (24 * 60 * 60 * 1000));
                    
                    // Debug logging for first few entries
                    if (areaData.indexOf(entry) < 3) {
                        console.log(`üîç Entry ${areaData.indexOf(entry)}:`, {
                            originalTime: entry.Time,
                            utcDate: utcDate.toISOString(),
                            copenhagenDate: copenhagenDate.toISOString(),
                            copenhagenHour: copenhagenHour,
                            daysDiff: daysDiff,
                            price: price
                        });
                    }
                    
                    // Assign til korrekt dag - UDEN yesterday
                    let targetDay = null;
                    if (daysDiff === 0) targetDay = 'today';
                    else if (daysDiff === 1) targetDay = 'tomorrow';
                    
                    if (targetDay && dayData.priser.length === 24) {
                        billigkwhDataSet[targetDay] = [...dayData.priser]; // Copy array
                        
                        const avgPrice = dayData.priser.reduce((sum, p) => sum + p, 0) / 24;
                        const minPrice = Math.min(...dayData.priser);
                        const maxPrice = Math.max(...dayData.priser);
                        
                        console.log(`‚úÖ BilligkWh ${targetDay}: 24 hours, ${minPrice.toFixed(3)}-${maxPrice.toFixed(3)} kr/kWh (avg ${avgPrice.toFixed(3)})`);
                    } else if (targetDay) {
                        console.log(`‚ö†Ô∏è BilligkWh ${targetDay}: Invalid data - ${dayData.priser.length} hours instead of 24`);
                    }
                    
                } catch (parseError) {
                    console.warn('‚ö†Ô∏è Could not parse BilligkWh day:', parseError, dayData);
                }
            });
            
            console.log('‚úÖ BilligkWh data organization completed');
            
        } catch (error) {
            console.error('‚ùå Error organizing BilligkWh data:', error);
        }
    }

    // Check if BilligkWh has complete data for a specific day
    function hasBilligkWhDataForDay(day) {
        return billigkwhDataSet[day] && 
               Array.isArray(billigkwhDataSet[day]) && 
               billigkwhDataSet[day].length === 24 &&
               billigkwhDataSet[day].some(price => price > 0);
    }

    console.log('STEP 6: BilligkWh API integration functions created');

    // ==============================================
    // STEP 3: PRICE ENHANCEMENT + TARIFF CALCULATION
    // ==============================================

    // Enhanced calculation using BilligkWh as primary reference for better accuracy
    function calculateActualMissingComponents(teslaData, henrikData, eurRate, billigkwhData = null) {
        try {
            console.log('üîç Calibrating tariffs: Henrik vs BilligkWh/Tesla comparison...');
            
            // PRIORITET 1: Sammenlign med BilligkWh data hvis tilg√¶ngelig
            if (billigkwhData && hasBilligkWhDataForDay('today')) {
                console.log('‚úÖ Using BilligkWh for calibration (most accurate)');
                return calibrateAgainstBilligkWh(henrikData, eurRate, billigkwhData);
            }
            
            // PRIORITET 2: Fallback til Tesla data
            const teslaTomorrow = teslaData.Elbil_price_data_tomorrow;
            const henrikTomorrow = henrikDataSet.tomorrow;
            
            if (!teslaTomorrow || !henrikTomorrow || 
                teslaTomorrow.length !== 24 || henrikTomorrow.length !== 24) {
                console.log('‚ö†Ô∏è Insufficient overlapping data for Tesla calibration');
                return null;
            }
            
            console.log('‚úÖ Using Tesla data for calibration (backup method)');
            return calibrateAgainstTesla(teslaTomorrow, henrikTomorrow, eurRate);
            
        } catch (error) {
            console.error('‚ùå Calibration failed:', error);
            return null;
        }
    }

    // Calibrate Henrik against BilligkWh (most accurate method)
    function calibrateAgainstBilligkWh(henrikData, eurRate, billigkwhData) {
        try {
            const henrikToday = henrikDataSet.today;
            const billigkwhToday = billigkwhDataSet.today;
            
            if (!henrikToday || !billigkwhToday || 
                henrikToday.length !== 24 || billigkwhToday.length !== 24) {
                console.log('‚ö†Ô∏è Insufficient BilligkWh overlapping data');
                return null;
            }
            
            console.log('üîç Calibrating Henrik vs BilligkWh for today...');
            
            // Convert Henrik EUR/MWh to kr/kWh (spot price only)
            const henrikSpotPrices = henrikToday.map(eurPerMWh => 
                (eurPerMWh / 1000) * eurRate
            );
            
            // Calculate missing components hour by hour
            const hourlyDifferences = [];
            const missingComponents = [];
            
            for (let hour = 0; hour < 24; hour++) {
                const billigkwhCompletePrice = billigkwhToday[hour];    // Complete Danish price
                const henrikSpotPrice = henrikSpotPrices[hour];         // Spot only
                
                const missing = billigkwhCompletePrice - henrikSpotPrice;
                
                hourlyDifferences.push({
                    hour,
                    billigkwhPrice: billigkwhCompletePrice,
                    henrikSpot: henrikSpotPrice,
                    missing: missing,
                    missingPercent: (missing / billigkwhCompletePrice) * 100
                });
                
                missingComponents.push(missing);
            }
            
            // Calculate statistics
            const avgMissing = missingComponents.reduce((sum, c) => sum + c, 0) / missingComponents.length;
            const minMissing = Math.min(...missingComponents);
            const maxMissing = Math.max(...missingComponents);
            const avgBilligkwhPrice = billigkwhToday.reduce((sum, p) => sum + p, 0) / billigkwhToday.length;
            const avgHenrikSpot = henrikSpotPrices.reduce((sum, p) => sum + p, 0) / henrikSpotPrices.length;
            
            console.log('üìä BilligkWh Calibration Results:');
            console.log(`üí∞ Average missing components: ${avgMissing.toFixed(3)} kr/kWh`);
            console.log(`üìà Range: ${minMissing.toFixed(3)} - ${maxMissing.toFixed(3)} kr/kWh`);
            console.log(`üìä Missing = ${((avgMissing / avgBilligkwhPrice) * 100).toFixed(1)}% of total price`);
            console.log(`‚ö° Henrik spot avg: ${avgHenrikSpot.toFixed(3)} kr/kWh`);
            console.log(`üèÅ BilligkWh complete avg: ${avgBilligkwhPrice.toFixed(3)} kr/kWh`);
            
            // Intelligent component breakdown based on BilligkWh
            const calibrated = {
                elafgift: 0.697,                                    // Fixed component
                variableTariffs: Math.max(0, avgMissing - 0.697),   // Rest = nettarif + system + margin
                momsIncluded: true,                                 // BilligkWh already has VAT
                hourlyVariation: hourlyDifferences,
                avgMissing: avgMissing,
                reliability: 'high',
                calibrationSource: 'BilligkWh'
            };
            
            // Further breakdown of variable tariffs
            calibrated.nettarif = calibrated.variableTariffs * 0.75;      // ~75% of variable
            calibrated.systemtarif = calibrated.variableTariffs * 0.15;   // ~15% of variable  
            calibrated.spottillaeg = calibrated.variableTariffs * 0.10;   // ~10% of variable
            calibrated.momsRate = 1.0; // No additional VAT needed
            
            return calibrated;
            
        } catch (error) {
            console.error('‚ùå BilligkWh calibration failed:', error);
            return null;
        }
    }

    // Calibrate Henrik against Tesla (backup method)
    function calibrateAgainstTesla(teslaTomorrow, henrikTomorrow, eurRate) {
        try {
            console.log('üîç Calibrating Henrik vs Tesla for tomorrow...');
            
            // Convert Henrik EUR/MWh to kr/kWh (spot price only)
            const henrikSpotPrices = henrikTomorrow.map(eurPerMWh => 
                (eurPerMWh / 1000) * eurRate
            );
            
            // Calculate missing components hour by hour
            const hourlyDifferences = [];
            const missingComponents = [];
            
            for (let hour = 0; hour < 24; hour++) {
                const teslaCompletePrice = teslaTomorrow[hour];     // Complete price
                const henrikSpotPrice = henrikSpotPrices[hour];     // Spot only
                
                const missing = teslaCompletePrice - henrikSpotPrice;
                
                hourlyDifferences.push({
                    hour,
                    teslaPrice: teslaCompletePrice,
                    henrikSpot: henrikSpotPrice,
                    missing: missing,
                    missingPercent: (missing / teslaCompletePrice) * 100
                });
                
                missingComponents.push(missing);
            }
            
            // Calculate statistics
            const avgMissing = missingComponents.reduce((sum, c) => sum + c, 0) / missingComponents.length;
            const minMissing = Math.min(...missingComponents);
            const maxMissing = Math.max(...missingComponents);
            const avgTeslaPrice = teslaTomorrow.reduce((sum, p) => sum + p, 0) / teslaTomorrow.length;
            const avgHenrikSpot = henrikSpotPrices.reduce((sum, p) => sum + p, 0) / henrikSpotPrices.length;
            
            console.log('üìä Tesla Calibration Results:');
            console.log(`üí∞ Average missing components: ${avgMissing.toFixed(3)} kr/kWh`);
            console.log(`üìà Range: ${minMissing.toFixed(3)} - ${maxMissing.toFixed(3)} kr/kWh`);
            console.log(`üìä Missing = ${((avgMissing / avgTeslaPrice) * 100).toFixed(1)}% of total price`);
            console.log(`‚ö° Henrik spot avg: ${avgHenrikSpot.toFixed(3)} kr/kWh`);
            console.log(`üèÅ Tesla complete avg: ${avgTeslaPrice.toFixed(3)} kr/kWh`);
            
            // Intelligent component breakdown
            const calibrated = {
                elafgift: 0.697,                                    // Fixed component
                variableTariffs: Math.max(0, avgMissing - 0.697),   // Rest = nettarif + system + margin
                momsIncluded: true,                                 // Tesla already has VAT
                hourlyVariation: hourlyDifferences,
                avgMissing: avgMissing,
                reliability: 'high',
                calibrationSource: 'Tesla'
            };
            
            // Further breakdown of variable tariffs
            calibrated.nettarif = calibrated.variableTariffs * 0.75;      // ~75% of variable
            calibrated.systemtarif = calibrated.variableTariffs * 0.15;   // ~15% of variable  
            calibrated.spottillaeg = calibrated.variableTariffs * 0.10;   // ~10% of variable
            calibrated.momsRate = 1.0; // No additional VAT needed
            
            return calibrated;
            
        } catch (error) {
            console.error('‚ùå Tesla calibration failed:', error);
            return null;
        }
    }

    // Get tariff components (calibrated or default)
    function getTariffComponents() {
        if (calibratedTariffComponents && calibratedTariffComponents.reliability === 'high') {
            return calibratedTariffComponents;
        }
        return defaultTariffComponents;
    }

    // Convert Henrik EUR/MWh spot price to Tesla-compatible complete price
    function enhanceHenrikPrice(eurPerMWh, eurRate, components = null) {
        if (!components) {
            components = getTariffComponents();
        }
        
        try {
            // Step 1: Convert EUR/MWh to kr/kWh (spot price only)
            const spotPriceKrKwh = (eurPerMWh / 1000) * eurRate;
            
            // Step 2: Add all missing components
            let totalPrice = spotPriceKrKwh;
            totalPrice += components.elafgift;      // Elafgift
            totalPrice += components.nettarif;      // Transport/distribution
            totalPrice += components.systemtarif;   // Energinet system tariff
            totalPrice += components.spottillaeg;   // Elselskab margin
            
            // Step 3: Apply VAT if needed
            if (components.momsRate > 1.0) {
                totalPrice *= components.momsRate;
            }
            
            return Math.max(0, totalPrice); // Ensure non-negative
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Price enhancement failed:', error);
            return eurPerMWh; // Return original on error
        }
    }

    // Enhance all Henrik data with current calibration
    async function enhanceAllHenrikData() {
        try {
            const eurRate = await fetchExchangeRate();
            const components = getTariffComponents();
            
            console.log('üîÑ Enhancing all Henrik data with tariffs...');
            console.log('üí± Using EUR rate:', eurRate);
            console.log('üìã Using components:', components);
            
            // Process each day that has Henrik data
            Object.keys(henrikDataSet).forEach(day => {
                if (hasHenrikDataForDay(day)) {
                    console.log(`üîÑ Enhancing ${day}...`);
                    
                    const originalPrices = [...henrikDataSet[day]];
                    henrikDataSet[day] = originalPrices.map(eurPerMWh => 
                        enhanceHenrikPrice(eurPerMWh, eurRate, components)
                    );
                    
                    const avgOriginal = originalPrices.reduce((sum, p) => sum + p, 0) / 24;
                    const avgEnhanced = henrikDataSet[day].reduce((sum, p) => sum + p, 0) / 24;
                    
                    console.log(`‚úÖ ${day}: ${avgOriginal.toFixed(2)} EUR/MWh ‚Üí ${avgEnhanced.toFixed(3)} kr/kWh`);
                }
            });
            
            console.log('‚úÖ All Henrik data enhanced');
            
        } catch (error) {
            console.error('‚ùå Henrik enhancement failed:', error);
        }
    }

    console.log('STEP 3: Price enhancement functions created');

    // ==============================================
    // STEP 4: SMART DATA PRIORITIZATION + 7-DAY UI
    // ==============================================

    // Generate dynamic day buttons with weekday labels - UDEN "I g√•r"
    function generateDayButtons() {
        const today = new Date();
        const days = ['s√∏n', 'man', 'tir', 'ons', 'tor', 'fre', 'l√∏r'];
        const dayButtons = [];
        
        for (let i = 0; i <= 5; i++) { // Fra i dag til om 5 dage (FJERNET i g√•r)
            const date = new Date(today);
            date.setDate(today.getDate() + i);
            
            let label, key;
            if (i === 0) {
                label = 'I dag';
                key = 'today';
            } else {
                // Alle dage fremover bruger ugedag forkortelse
                label = days[date.getDay()]; // Ugedag forkortelse
                if (i === 1) {
                    key = 'tomorrow';
                } else {
                    key = `day${i}`;
                }
            }
            
            dayButtons.push({ 
                key, 
                label, 
                date: new Date(date),
                dayOffset: i
            });
        }
        
        return dayButtons;
    }

    // Smart data prioritization: BilligkWh ‚Üí Tesla ‚Üí Henrik
    function getDataForDay(day) {
        // PRIORITET 1: BilligkWh data (komplette danske priser for i g√•r, i dag, i morgen)
        if (hasBilligkWhDataForDay(day)) {
            return {
                source: 'BilligkWh',
                data: billigkwhDataSet[day],
                reliable: true,
                color: 'blue'
            };
        }
        
        // PRIORITET 2: Tesla data (hvis tilg√¶ngelig og komplet)
        if (priceDataSet[day] && Array.isArray(priceDataSet[day]) && priceDataSet[day].length === 24) {
            const hasValidData = priceDataSet[day].some(price => price > 0);
            if (hasValidData) {
                return {
                    source: 'Tesla',
                    data: priceDataSet[day],
                    reliable: true,
                    color: 'green'
                };
            }
        }
        
        // PRIORITET 3: Enhanced Henrik data (6-dages backup)
        if (hasHenrikDataForDay(day)) {
            const reliabilityMap = {
                'today': true,
                'tomorrow': true,
                'day2': true,
                'day3': true,
                'day4': false,  // Henrik p√•lidelig, men l√¶ngere frem
                'day5': false,
                'day6': false
            };
            
            return {
                source: 'Henrik+tariffer',
                data: henrikDataSet[day],
                reliable: reliabilityMap[day] || false,
                color: reliabilityMap[day] ? 'orange' : 'gray'
            };
        }
        
        // Ingen data tilg√¶ngelig
        return {
            source: 'none',
            data: [],
            reliable: false,
            color: 'red'
        };
    }

    // Update day selector HTML with 7 buttons
    function updateDaySelector() {
        try {
            const dayButtons = generateDayButtons();
            const selector = document.querySelector('.time-selector');
            
            if (!selector) {
                console.error('‚ùå Day selector element not found');
                return;
            }
            
            // Clear existing buttons
            selector.innerHTML = '';
            
            // Create buttons dynamically
            dayButtons.forEach((dayInfo, index) => {
                const button = document.createElement('div');
                button.className = 'time-option';
                button.textContent = dayInfo.label;
                button.setAttribute('data-day', dayInfo.key);
                
                // Set active button (default to today only)
                if (dayInfo.key === currentDay || (dayInfo.key === 'today' && currentDay === 'today')) {
                    button.classList.add('active');
                }
                
                // Add click handler with closure to preserve dayInfo
                button.addEventListener('click', function(event) {
                    switchDayEnhanced(dayInfo.key, event);
                });
                
                selector.appendChild(button);
            });
            
            console.log('‚úÖ Day selector updated with 7 buttons');
            
        } catch (error) {
            console.error('‚ùå Error updating day selector:', error);
        }
    }

    // Enhanced switchDay function with smart data prioritization
    function switchDayEnhanced(day, event) {
        try {
            console.log('üîÑ STATUS: Enhanced switchDay called for:', day);
            
            // Update active button
            document.querySelectorAll('.time-option').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // Update current day
            currentDay = day;
            
            // Get smart data for the day
            const dayData = getDataForDay(day);
            priceData = dayData.data;
            
            console.log(`‚úÖ Using ${dayData.source} data for ${day}:`, priceData.length, 'prices');
            
            // Update data source indicator (if element exists)
            const sourceElement = document.getElementById('dataSource');
            const reliabilityElement = document.getElementById('reliability');
            
            if (sourceElement) {
                sourceElement.textContent = dayData.source;
            }
            
            if (reliabilityElement) {
                reliabilityElement.style.color = dayData.color;
                reliabilityElement.textContent = dayData.reliable ? '‚óè' : '‚óê';
                reliabilityElement.title = dayData.reliable ? 'P√•lidelig data' : 'Prognosticeret data';
            }
            
            // Regenerate chart with new data
            generateChart();
            
            console.log('‚úÖ STATUS: Enhanced switchDay completed for', day);
            
        } catch (error) {
            console.error('‚ùå Error in enhanced switchDay:', error);
            // Fallback to original behavior - UDEN yesterday
            if (day === 'today') {
                priceData = priceDataSet.today;
            } else if (day === 'tomorrow') {
                priceData = priceDataSet.tomorrow;
            } else {
                priceData = [];
            }
            generateChart();
        }
    }

    // Original switchDay function for backward compatibility
    function switchDay(day) {
        // Delegate to enhanced function for backward compatibility
        switchDayEnhanced(day, event);
    }

    // Update hasDataForDay to work with both Tesla and Henrik
    function hasDataForDayEnhanced(day) {
        const dayData = getDataForDay(day);
        return dayData.source !== 'none' && dayData.data.length === 24;
    }

    // Enhanced data availability check
    function hasDataForDay(day) {
        // Use enhanced version that checks both Tesla and Henrik
        return hasDataForDayEnhanced(day);
    }

    console.log('STEP 4: Smart data prioritization and 7-day UI functions created');

    // ==============================================
    // ENHANCED CHART GENERATION + TOOLTIP SYSTEM
    // ==============================================

    // Tooltip system
    const tooltipPortal = document.getElementById('tooltipPortal');
    let activeBar = null;

    function showTooltip(barElement, text) {
        activeBar = barElement;
        const rect = barElement.getBoundingClientRect();
        
        tooltipPortal.textContent = text;
        tooltipPortal.style.left = (rect.left + rect.width / 2) + 'px';
        tooltipPortal.style.top = (rect.top - 8) + 'px';
        tooltipPortal.style.transform = 'translate(-50%, -100%)';
        tooltipPortal.classList.add('visible');
    }

    function hideTooltip() {
        activeBar = null;
        tooltipPortal.classList.remove('visible');
    }

    // Enhanced chart generation with 7-day support
    function generateChartEnhanced() {
        console.log('üîÑ STATUS: Generating enhanced chart for', currentDay, '- data length:', priceData.length);
        
        const chart = document.getElementById('priceChart');
        chart.innerHTML = '';
        
        // Get current day info for enhanced display
        const dayData = getDataForDay(currentDay);
        
        // Check if we have data
        if (!hasDataForDayEnhanced(currentDay)) {
            showEmptyStateEnhanced(currentDay, dayData);
            return;
        }
        
        const maxPrice = Math.max(...priceData);
        
        // Get Copenhagen current time for proper current hour detection
        const now = new Date();
        const copenhagenNow = new Date(now.toLocaleString("en-US", {timeZone: "Europe/Copenhagen"}));
        const currentHour = copenhagenNow.getHours();
        
        priceData.forEach((price, index) => {
            const bar = document.createElement('div');
            bar.className = 'bar';
            
            const height = Math.max((price / maxPrice) * 100, 5);
            bar.style.height = height + '%';
            
            // Enhanced tooltip with source info
            let tooltipText = `${index.toString().padStart(2, '0')}:00 - ${price.toFixed(3).replace('.', ',')} kr/kWh`;
            if (dayData.source !== 'Tesla') {
                tooltipText += ` (${dayData.source})`;
            }
            
            bar.addEventListener('mouseenter', function(e) {
                showTooltip(this, tooltipText);
            });
            
            bar.addEventListener('mouseleave', function(e) {
                hideTooltip();
            });
            
            bar.addEventListener('touchstart', function(e) {
                e.preventDefault();
                this.classList.add('touch-active');
                showTooltip(this, tooltipText);
                
                document.querySelectorAll('.bar').forEach(otherBar => {
                    if (otherBar !== this) {
                        otherBar.classList.remove('touch-active');
                    }
                });
                
                setTimeout(() => {
                    this.classList.remove('touch-active');
                    if (activeBar === this) {
                        hideTooltip();
                    }
                }, 3000);
            }, { passive: false });
            
            bar.addEventListener('touchend', function(e) {
                e.preventDefault();
            }, { passive: false });
            
            bar.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
            
            // Enhanced bar styling with 7-day charging support
            const currentChargingHours = chargingSchedule[currentDay] || [];
            const isCharging = currentChargingHours.includes(index);
            
            const isPastHour = (currentDay === 'today' && index < currentHour);
            
            const isCurrentTime = (currentDay === 'today' && index === currentHour);
            
            if (isCurrentTime) {
                bar.classList.add('current-time');
            } else if (isCharging) {
                bar.classList.add('charging');
                if (isPastHour) bar.classList.add('past');
            } else {
                // Enhanced color coding based on data source
                if (dayData.source === 'Henrik+tariffer') {
                    // Slightly different color scheme for Henrik data
                    if (price < 2.3) {        
                        bar.classList.add('green');
                    } else if (price < 3.3) {  
                        bar.classList.add('orange');
                    } else {                  
                        bar.classList.add('red');
                    }
                } else {
                    // Original Tesla color scheme
                    if (price < 2.5) {        
                        bar.classList.add('green');
                    } else if (price < 3.5) {  
                        bar.classList.add('orange');
                    } else {                  
                        bar.classList.add('red');
                    }
                }
                
                if (isPastHour) bar.classList.add('past');
            }
            
            chart.appendChild(bar);
        });
        
        console.log('‚úÖ STATUS: Enhanced chart generation completed for', currentDay);
    }

    // Enhanced empty state with data source info
    function showEmptyStateEnhanced(day, dayData) {
        console.log('üîÑ STATUS: Showing enhanced empty state for', day);
        
        const chart = document.getElementById('priceChart');
        
        const emptyState = document.createElement('div');
        emptyState.className = 'empty-state';
        
        const mainMessage = document.createElement('div');
        mainMessage.className = 'main-message';
        
        const subMessage = document.createElement('div');
        subMessage.className = 'sub-message';
        
        // Enhanced empty state messages
        if (day === 'tomorrow') {
            const now = new Date();
            const copenhagenNow = new Date(now.toLocaleString("en-US", {timeZone: "Europe/Copenhagen"}));
            const currentHour = copenhagenNow.getHours();
            
            if (currentHour < 13) {
                mainMessage.textContent = 'Ikke klar endnu';
                subMessage.textContent = 'Priser bliver normalt\ntilg√¶ngelige efter kl. 13:00';
            } else {
                mainMessage.textContent = 'Ingen data';
                subMessage.textContent = 'Hverken Tesla eller Henrik\ndata er tilg√¶ngeligt';
            }
        } else if (day.startsWith('day')) {
            mainMessage.textContent = 'Henrik prognose';
            subMessage.textContent = 'Venter p√• 7-dages prognosedata\nfra Henrik Solm√∏ller';
        } else {
            mainMessage.textContent = 'Ingen data';
            subMessage.textContent = 'K√∏r Tesla script for at\ngenerere ladeplan og priser';
        }
        
        emptyState.appendChild(mainMessage);
        emptyState.appendChild(subMessage);
        chart.appendChild(emptyState);
    }

    // Main chart generation function
    function generateChart() {
        // Use enhanced version for all chart generation
        generateChartEnhanced();
    }

    // Empty state fallback
    function showEmptyState(day) {
        // Use enhanced version
        const dayData = getDataForDay(day);
        showEmptyStateEnhanced(day, dayData);
    }

    console.log('Enhanced chart generation and tooltip system created');

    // ==============================================
    // TESLA DATA INTEGRATION + MAIN FETCH FUNCTIONS
    // ==============================================

    // Enhanced Tesla data fetching with BilligkWh + Henrik integration
    async function fetchTeslaData() {
        try {
            console.log('üîÑ STATUS: Fetching all data sources...');
            
            // PARALLEL FETCH: Tesla, EUR rate, BilligkWh
            const [teslaResponse, eurRate, billigkwhData] = await Promise.all([
                fetch(CONFIG.dataURL + '?t=' + Date.now()),
                fetchExchangeRate(),
                fetchBilligkWhData()
            ]);
            
            if (!teslaResponse.ok) {
                throw new Error(`Tesla HTTP ${teslaResponse.status}`);
            }
            
            const teslaData = await teslaResponse.json();
            console.log('üîÑ STATUS: Tesla data received, processing...');
            
            // Standard Tesla data update
            updateUIWithTeslaData(teslaData);
            
            // STEP 6: BilligkWh integration result
            if (billigkwhData) {
                console.log('
                    if (daysDiff === 0) targetDay = 'today';
                    else if (daysDiff === 1) targetDay = 'tomorrow';
                    else if (daysDiff === 2) targetDay = 'day2';
                    else if (daysDiff === 3) targetDay = 'day3';
                    else if (daysDiff === 4) targetDay = 'day4';
                    else if (daysDiff === 5) targetDay = 'day5';
                    else if (daysDiff === 6) targetDay = 'day6';
                    
                    if (targetDay && copenhagenHour >= 0 && copenhagenHour <= 23) {
                        // S√∏rg for array er initialiseret med 24 elementer
                        if (henrikDataSet[targetDay].length === 0) {
                            henrikDataSet[targetDay] = new Array(24).fill(0);
                        }
                        henrikDataSet[targetDay][copenhagenHour] = price;
                    }
                    
                } catch (parseError) {
                    console.warn('‚ö†Ô∏è Could not parse Henrik entry:', parseError, entry);
                }
            });
            
            // Log resultater med timezone info
            console.log('üïí Timezone conversion: UTC ‚Üí Europe/Copenhagen');
            Object.keys(henrikDataSet).forEach(day => {
                if (henrikDataSet[day].length === 24) {
                    const validPrices = henrikDataSet[day].filter(p => p > 0);
                    if (validPrices.length > 0) {
                        const avgPrice = validPrices.reduce((sum, p) => sum + p, 0) / validPrices.length;
                        const minPrice = Math.min(...validPrices);
                        const maxPrice = Math.max(...validPrices);
                        console.log(`‚úÖ Henrik ${day}: ${validPrices.length}/24 hours, ${minPrice.toFixed(1)}-${maxPrice.toFixed(1)} EUR/MWh (avg ${avgPrice.toFixed(1)})`);
                    } else {
                        console.log(`‚ö†Ô∏è Henrik ${day}: 24 hours initialized but no valid prices`);
                    }
                } else {
                    console.log(`‚ùå Henrik ${day}: no data`);
                }
            });
            
        } catch (error) {
            console.error('‚ùå Error organizing Henrik data:', error);
        }
    }

    // Check if Henrik has complete data for a specific day
    function hasHenrikDataForDay(day) {
        return henrikDataSet[day] && 
               Array.isArray(henrikDataSet[day]) && 
               henrikDataSet[day].length === 24 &&
               henrikDataSet[day].some(price => price > 0);
    }

    console.log('STEP 2: Henrik Solmoller data functions created');

    // ==============================================
    // STEP 6: BILLIGKWH API INTEGRATION
    // ==============================================

    // Fetch BilligkWh 3-day prices (i g√•r, i dag, i morgen)
    async function fetchBilligkWhData() {
        try {
            console.log('üí∞ Fetching BilligkWh prices...');
            
            const response = await fetch(CONFIG.billigkwhURL + '&t=' + Date.now(), {
                headers: {
                    'User-Agent': 'Tesla-Dashboard/1.0'
                }
            });
            
            if (!response.ok) {
                throw new Error(`BilligkWh API HTTP ${response.status}`);
            }
            
            const billigkwhData = await response.json();
            console.log('‚úÖ BilligkWh data received');
            console.log('üìÖ Available days:', billigkwhData.length);
            
            // Parse og organiser BilligkWh data i 3-dages struktur
            updateBilligkWhDataSet(billigkwhData);
            
            return billigkwhData;
            
        } catch (error) {
            console.warn('‚ö†Ô∏è BilligkWh data fetch failed:', error);
            console.log('üîß CORS Error? Falling back to Tesla + Henrik data');
            // Clear BilligkWh data ved fejl
            Object.keys(billigkwhDataSet).forEach(day => billigkwhDataSet[day] = []);
            return null;
        }
    }

    // Organiser BilligkWh data i daglige arrays med Copenhagen timezone
    function updateBilligkWhDataSet(billigkwhData) {
        try {
            console.log('üîÑ Organizing BilligkWh data into 3-day structure...');
            
            // Clear existing data
            Object.keys(billigkwhDataSet).forEach(day => billigkwhDataSet[day] = []);
            
            if (!billigkwhData || !Array.isArray(billigkwhData)) {
                console.warn('‚ö†Ô∏è Invalid BilligkWh data format - not an array');
                return;
            }
            
            // Get current Copenhagen time for day calculations
            const now = new Date();
            const copenhagenNow = new Date(now.toLocaleString("en-US", {timeZone: "Europe/Copenhagen"}));
            const copenhagenToday = new Date(copenhagenNow.getFullYear(), copenhagenNow.getMonth(), copenhagenNow.getDate());
            
            console.log('üïí Copenhagen current time:', copenhagenNow.toISOString());
            console.log('üìä Processing BilligkWh data:', billigkwhData.length, 'days');
            
            // Process each day from BilligkWh - format: [{dato: "2025-06-06T00:00:00", priser: [24 prices]}]
            billigkwhData.forEach((dayData, index) => {
                try {
                    if (!dayData.dato || !dayData.priser || !Array.isArray(dayData.priser)) {
                        console.log(`‚ö†Ô∏è Invalid day data at index ${index}:`, dayData);
                        return;
                    }
                    
                    // Parse BilligkWh date
                    const billigkwhDate = new Date(dayData.dato);
                    const billigkwhDay = new Date(billigkwhDate.getFullYear(), billigkwhDate.getMonth(), billigkwhDate.getDate());
                    
                    // Calculate day offset from Copenhagen today
                    const daysDiff = Math.floor((billigkwhDay - copenhagenToday) / (24 * 60 * 60 * 1000));
                    
                    // Debug logging for first few entries
                    if (index < 3) {
                        console.log(`üîç Day ${index}:`, {
                            originalDate: dayData.dato,
                            parsedDate: billigkwhDate.toISOString(),
                            daysDiff: daysDiff,
                            pricesLength: dayData.priser.length
                        });
                    }
                    
                    // Assign til korrekt dag - UDEN yesterday
                    let targetDay = null;
